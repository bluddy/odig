<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Strict_promise_builder (sugar.Sugar__.Strict_promise_builder)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">sugar</a> &#x00BB; <a href="../index.html">Sugar__</a> &#x00BB; Strict_promise_builder</nav><h1>Module <code>Sugar__.Strict_promise_builder</code></h1></header><aside><p>This module is similar to <a href="../../Sugar__Promise_builder/index.html"><span>Sugar.Promise</span></a>. It lets you create a result monad on top of an arbitrary monad.</p><p>The main difference is that the functions in this module were created to recognize unexpected exceptions, and require you to provide some mecanism to recover from that. This is done with the signatures for <a href="../../Sugar/S/Params/module-type-Strict_error/index.html"><span>strict error</span></a> and <a href="../../Sugar/S/Params/module-type-Strict_monad/index.html"><span>strict monad</span></a>.</p><p>An example:</p><pre><code class="ml">module MyError = struct
  type t = A | B | Unexpected of exn

  let panic e = Unexpected e
end

module MyMonad = struct
  type 'a t = 'a Lwt.t
  let return = Lwt.return
  let (&gt;&gt;=) = Lwt.(&gt;&gt;=)
  let catch = Lwt.catch
end

module MyResult = Sugar.Strict.Promise.Make (MyError) (MyMonad)</code></pre><p>Notice that the signature for the required strict monad is the same as the Lwt library. That means, you can just plug it in:</p><pre><code class="ml">module MyResult = Sugar.Strict.Promise.Make (MyError) (Lwt)</code></pre></aside><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-UserError/index.html">UserError</a> : <a href="../../Sugar/S/Params/index.html#module-type-Strict_error">Sugar.S.Params.Strict_error</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-UserMonad/index.html">UserMonad</a> : <a href="../../Sugar/S/Params/index.html#module-type-Strict_monad">Sugar.S.Params.Strict_monad</a>) <span>&#45;&gt;</span> <a href="../../Sugar/S/index.html#module-type-Strict_promise">Sugar.S.Strict_promise</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-error">error</a> := <a href="Make/argument-1-UserError/index.html#type-t">UserError.t</a> <span class="keyword">and</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-monad">monad</a> := <span class="type-var">'a</span> <a href="Make/argument-2-UserMonad/index.html#type-t">UserMonad.t</a> <span class="keyword">and</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-value">value</a> = (<span class="type-var">'a</span>, <a href="Make/argument-1-UserError/index.html#type-t">UserError.t</a>) <a href="../../../result/Result/index.html#type-result">Result.result</a> <span class="keyword">and</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-result">result</a> = (<span class="type-var">'a</span>, <a href="Make/argument-1-UserError/index.html#type-t">UserError.t</a>) <a href="../../../result/Result/index.html#type-result">Result.result</a> <a href="Make/argument-2-UserMonad/index.html#type-t">UserMonad.t</a></code></dt><dd><p>A parametric module that implements the monadic interface for values. The complete documentation can be found in <a href="../S/module-type-Promise/index.html"><code>Sugar.S.Promise</code></a>.</p></dd></dl></div></body></html>