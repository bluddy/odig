<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pcre (pcre.Pcre)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">pcre</a> &#x00BB; Pcre</nav><h1>Module <code>Pcre</code></h1><p>Perl Compatibility Regular Expressions for OCaml</p><p><em>7.4.1 - <a href="https://mmottl.github.io/pcre-ocaml">homepage</a></em></p><nav class="toc"><ul><li><a href="#exceptions">Exceptions</a></li><li><a href="#compilation-and-runtime-flags-and-their-conversion-functions">Compilation and runtime flags and their conversion functions</a></li><li><a href="#information-on-the-pcre-configuration-(build-time-options)">Information on the PCRE-configuration (build-time options)</a></li><li><a href="#information-on-patterns">Information on patterns</a></li><li><a href="#compilation-of-patterns">Compilation of patterns</a></li><li><a href="#subpattern-extraction">Subpattern extraction</a></li><li><a href="#callouts">Callouts</a></li><li><a href="#matching-of-patterns-and-subpattern-extraction">Matching of patterns and subpattern extraction</a></li><li><a href="#string-substitution">String substitution</a></li><li><a href="#splitting">Splitting</a></li><li><a href="#additional-convenience-functions">Additional convenience functions</a></li><li><a href="#unsafe-stuff---use-with-caution!"><b>UNSAFE STUFF - USE WITH CAUTION!</b></a></li></ul></nav></header><section><header><h6 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h6></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code><code> = </code><table class="variant"><tr id="type-error.Partial" class="anchored"><td class="def constructor"><a href="#type-error.Partial" class="anchor"></a><code>| </code><code><span class="constructor">Partial</span></code></td><td class="doc"><p>String only matched the pattern partially</p></td></tr><tr id="type-error.BadPartial" class="anchored"><td class="def constructor"><a href="#type-error.BadPartial" class="anchor"></a><code>| </code><code><span class="constructor">BadPartial</span></code></td><td class="doc"><p>Pattern contains items that cannot be used together with partial matching.</p></td></tr><tr id="type-error.BadPattern" class="anchored"><td class="def constructor"><a href="#type-error.BadPattern" class="anchor"></a><code>| </code><code><span class="constructor">BadPattern</span> <span class="keyword">of</span> string * int</code></td><td class="doc"><p><code>BadPattern (msg, pos)</code> regular expression is malformed. The reason is in <code>msg</code>, the position of the error in the pattern in <code>pos</code>.</p></td></tr><tr id="type-error.BadUTF8" class="anchored"><td class="def constructor"><a href="#type-error.BadUTF8" class="anchor"></a><code>| </code><code><span class="constructor">BadUTF8</span></code></td><td class="doc"><p>UTF8 string being matched is invalid</p></td></tr><tr id="type-error.BadUTF8Offset" class="anchored"><td class="def constructor"><a href="#type-error.BadUTF8Offset" class="anchor"></a><code>| </code><code><span class="constructor">BadUTF8Offset</span></code></td><td class="doc"><p>Gets raised when a UTF8 string being matched with offset is invalid.</p></td></tr><tr id="type-error.MatchLimit" class="anchored"><td class="def constructor"><a href="#type-error.MatchLimit" class="anchor"></a><code>| </code><code><span class="constructor">MatchLimit</span></code></td><td class="doc"><p>Maximum allowed number of match attempts with backtracking or recursion is reached during matching. ALL FUNCTIONS CALLING THE MATCHING ENGINE MAY RAISE IT!!!</p></td></tr><tr id="type-error.RecursionLimit" class="anchored"><td class="def constructor"><a href="#type-error.RecursionLimit" class="anchor"></a><code>| </code><code><span class="constructor">RecursionLimit</span></code></td></tr><tr id="type-error.WorkspaceSize" class="anchored"><td class="def constructor"><a href="#type-error.WorkspaceSize" class="anchor"></a><code>| </code><code><span class="constructor">WorkspaceSize</span></code></td><td class="doc"><p>Raised by <a href="index.html#val-pcre_dfa_exec"><code>pcre_dfa_exec</code></a> when the provided workspace array is too small. See documention on <a href="index.html#val-pcre_dfa_exec"><code>pcre_dfa_exec</code></a> for details on workspace array sizing.</p></td></tr><tr id="type-error.InternalError" class="anchored"><td class="def constructor"><a href="#type-error.InternalError" class="anchor"></a><code>| </code><code><span class="constructor">InternalError</span> <span class="keyword">of</span> string</code></td><td class="doc"><p><code>InternalError msg</code> C-library exhibits unknown/undefined behaviour. The reason is in <code>msg</code>.</p></td></tr></table></dt></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span> <span class="keyword">of</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Exception indicating PCRE errors.</p></dd></dl><dl><dt class="spec exception" id="exception-Backtrack"><a href="#exception-Backtrack" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Backtrack</span></code></dt><dd><p><code>Backtrack</code> used in callout functions to force backtracking.</p></dd></dl><dl><dt class="spec exception" id="exception-Regexp_or"><a href="#exception-Regexp_or" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Regexp_or</span> <span class="keyword">of</span> string * <a href="index.html#type-error">error</a></code></dt><dd><p><code>Regexp_or (pat, error)</code> gets raised for sub-pattern <code>pat</code> by <code>regexp_or</code> if it failed to compile.</p></dd></dl></section><section><header><h6 id="compilation-and-runtime-flags-and-their-conversion-functions"><a href="#compilation-and-runtime-flags-and-their-conversion-functions" class="anchor"></a>Compilation and runtime flags and their conversion functions</h6></header><dl><dt class="spec type" id="type-icflag"><a href="#type-icflag" class="anchor"></a><code><span class="keyword">type</span> icflag</code></dt><dd><p>Internal representation of compilation flags</p></dd></dl><dl><dt class="spec type" id="type-irflag"><a href="#type-irflag" class="anchor"></a><code><span class="keyword">and</span> irflag</code></dt><dd><p>Internal representation of runtime flags</p></dd></dl><dl><dt class="spec type" id="type-cflag"><a href="#type-cflag" class="anchor"></a><code><span class="keyword">and</span> cflag</code> = <code>[ </code><table class="variant"><tr id="type-cflag.CASELESS" class="anchored"><td class="def constructor"><a href="#type-cflag.CASELESS" class="anchor"></a><code>| </code><code>`CASELESS</code></td><td class="doc"><p>Case insensitive matching</p></td></tr><tr id="type-cflag.MULTILINE" class="anchored"><td class="def constructor"><a href="#type-cflag.MULTILINE" class="anchor"></a><code>| </code><code>`MULTILINE</code></td><td class="doc"><p>'^' and '$' match before/after newlines, not just at the beginning/end of a string</p></td></tr><tr id="type-cflag.DOTALL" class="anchored"><td class="def constructor"><a href="#type-cflag.DOTALL" class="anchor"></a><code>| </code><code>`DOTALL</code></td><td class="doc"><p>'.' matches all characters (newlines, too)</p></td></tr><tr id="type-cflag.EXTENDED" class="anchored"><td class="def constructor"><a href="#type-cflag.EXTENDED" class="anchor"></a><code>| </code><code>`EXTENDED</code></td><td class="doc"><p>Ignores whitespace and PERL-comments. Behaves like the '/x'-option in PERL</p></td></tr><tr id="type-cflag.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-cflag.ANCHORED" class="anchor"></a><code>| </code><code>`ANCHORED</code></td><td class="doc"><p>Pattern matches only at start of string</p></td></tr><tr id="type-cflag.DOLLAR_ENDONLY" class="anchored"><td class="def constructor"><a href="#type-cflag.DOLLAR_ENDONLY" class="anchor"></a><code>| </code><code>`DOLLAR_ENDONLY</code></td><td class="doc"><p>'$' in pattern matches only at end of string</p></td></tr><tr id="type-cflag.EXTRA" class="anchored"><td class="def constructor"><a href="#type-cflag.EXTRA" class="anchor"></a><code>| </code><code>`EXTRA</code></td><td class="doc"><p>Reserved for future extensions of PCRE</p></td></tr><tr id="type-cflag.UNGREEDY" class="anchored"><td class="def constructor"><a href="#type-cflag.UNGREEDY" class="anchor"></a><code>| </code><code>`UNGREEDY</code></td><td class="doc"><p>Quantifiers not greedy anymore, only if followed by '?'</p></td></tr><tr id="type-cflag.UTF8" class="anchored"><td class="def constructor"><a href="#type-cflag.UTF8" class="anchor"></a><code>| </code><code>`UTF8</code></td><td class="doc"><p>Treats patterns and strings as UTF8 characters.</p></td></tr><tr id="type-cflag.NO_UTF8_CHECK" class="anchored"><td class="def constructor"><a href="#type-cflag.NO_UTF8_CHECK" class="anchor"></a><code>| </code><code>`NO_UTF8_CHECK</code></td><td class="doc"><p>Turns off validity checks on UTF8 strings for efficiency reasons. WARNING: invalid UTF8 strings may cause a crash then!</p></td></tr><tr id="type-cflag.NO_AUTO_CAPTURE" class="anchored"><td class="def constructor"><a href="#type-cflag.NO_AUTO_CAPTURE" class="anchor"></a><code>| </code><code>`NO_AUTO_CAPTURE</code></td><td class="doc"><p>Disables the use of numbered capturing parentheses</p></td></tr><tr id="type-cflag.AUTO_CALLOUT" class="anchored"><td class="def constructor"><a href="#type-cflag.AUTO_CALLOUT" class="anchor"></a><code>| </code><code>`AUTO_CALLOUT</code></td><td class="doc"><p>Automatically inserts callouts with id 255 before each pattern item</p></td></tr><tr id="type-cflag.FIRSTLINE" class="anchored"><td class="def constructor"><a href="#type-cflag.FIRSTLINE" class="anchor"></a><code>| </code><code>`FIRSTLINE</code></td><td class="doc"><p>Unanchored patterns must match before/at first NL</p></td></tr></table><code> ]</code></dt><dd><p>Compilation flags</p></dd></dl><dl><dt class="spec value" id="val-cflags"><a href="#val-cflags" class="anchor"></a><code><span class="keyword">val</span> cflags : <a href="index.html#type-cflag">cflag</a> list <span>&#45;&gt;</span> <a href="index.html#type-icflag">icflag</a></code></dt><dd><p><code>cflags cflag_list</code> converts a list of compilation flags to their internal representation.</p></dd></dl><dl><dt class="spec value" id="val-cflag_list"><a href="#val-cflag_list" class="anchor"></a><code><span class="keyword">val</span> cflag_list : <a href="index.html#type-icflag">icflag</a> <span>&#45;&gt;</span> <a href="index.html#type-cflag">cflag</a> list</code></dt><dd><p><code>cflag_list cflags</code> converts internal representation of compilation flags to a list.</p></dd></dl><dl><dt class="spec type" id="type-rflag"><a href="#type-rflag" class="anchor"></a><code><span class="keyword">type</span> rflag</code> = <code>[ </code><table class="variant"><tr id="type-rflag.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-rflag.ANCHORED" class="anchor"></a><code>| </code><code>`ANCHORED</code></td><td class="doc"><p>Treats pattern as if it were anchored</p></td></tr><tr id="type-rflag.NOTBOL" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTBOL" class="anchor"></a><code>| </code><code>`NOTBOL</code></td><td class="doc"><p>Beginning of string is not treated as beginning of line</p></td></tr><tr id="type-rflag.NOTEOL" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTEOL" class="anchor"></a><code>| </code><code>`NOTEOL</code></td><td class="doc"><p>End of string is not treated as end of line</p></td></tr><tr id="type-rflag.NOTEMPTY" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTEMPTY" class="anchor"></a><code>| </code><code>`NOTEMPTY</code></td><td class="doc"><p>Empty strings are not considered to be a valid match</p></td></tr><tr id="type-rflag.PARTIAL" class="anchored"><td class="def constructor"><a href="#type-rflag.PARTIAL" class="anchor"></a><code>| </code><code>`PARTIAL</code></td><td class="doc"><p>Turns on partial matching</p></td></tr><tr id="type-rflag.DFA_RESTART" class="anchored"><td class="def constructor"><a href="#type-rflag.DFA_RESTART" class="anchor"></a><code>| </code><code>`DFA_RESTART</code></td><td class="doc"><p>Causes matching to proceed presuming the subject string is further to one partially matched previously using the same int-array working set. May only be used with <a href="index.html#val-pcre_dfa_exec"><code>pcre_dfa_exec</code></a> or <a href="index.html#val-unsafe_pcre_dfa_exec"><code>unsafe_pcre_dfa_exec</code></a>, and should always be paired with <code>`PARTIAL</code>.</p></td></tr></table><code> ]</code></dt><dd><p>Runtime flags</p></dd></dl><dl><dt class="spec value" id="val-rflags"><a href="#val-rflags" class="anchor"></a><code><span class="keyword">val</span> rflags : <a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> <a href="index.html#type-irflag">irflag</a></code></dt><dd><p><code>rflags rflag_list</code> converts a list of runtime flags to their internal representation.</p></dd></dl><dl><dt class="spec value" id="val-rflag_list"><a href="#val-rflag_list" class="anchor"></a><code><span class="keyword">val</span> rflag_list : <a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> <a href="index.html#type-rflag">rflag</a> list</code></dt><dd><p><code>rflag_list rflags</code> converts internal representation of runtime flags to a list.</p></dd></dl></section><section><header><h6 id="information-on-the-pcre-configuration-(build-time-options)"><a href="#information-on-the-pcre-configuration-(build-time-options)" class="anchor"></a>Information on the PCRE-configuration (build-time options)</h6></header><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val</span> version : string</code></dt><dd><p>Version information</p><p>Version of the PCRE-C-library</p></dd></dl><dl><dt class="spec value" id="val-config_utf8"><a href="#val-config_utf8" class="anchor"></a><code><span class="keyword">val</span> config_utf8 : bool</code></dt><dd><p>Indicates whether UTF8-support is enabled</p></dd></dl><dl><dt class="spec value" id="val-config_newline"><a href="#val-config_newline" class="anchor"></a><code><span class="keyword">val</span> config_newline : char</code></dt><dd><p>Character used as newline</p></dd></dl><dl><dt class="spec value" id="val-config_link_size"><a href="#val-config_link_size" class="anchor"></a><code><span class="keyword">val</span> config_link_size : int</code></dt><dd><p>Number of bytes used for internal linkage of regular expressions</p></dd></dl><dl><dt class="spec value" id="val-config_match_limit"><a href="#val-config_match_limit" class="anchor"></a><code><span class="keyword">val</span> config_match_limit : int</code></dt><dd><p>Default limit for calls to internal matching function</p></dd></dl><dl><dt class="spec value" id="val-config_match_limit_recursion"><a href="#val-config_match_limit_recursion" class="anchor"></a><code><span class="keyword">val</span> config_match_limit_recursion : int</code></dt><dd><p>Default limit recursion for calls to internal matching function</p></dd></dl><dl><dt class="spec value" id="val-config_stackrecurse"><a href="#val-config_stackrecurse" class="anchor"></a><code><span class="keyword">val</span> config_stackrecurse : bool</code></dt><dd><p>Indicates use of stack recursion in matching function</p></dd></dl></section><section><header><h6 id="information-on-patterns"><a href="#information-on-patterns" class="anchor"></a>Information on patterns</h6></header><dl><dt class="spec type" id="type-firstbyte_info"><a href="#type-firstbyte_info" class="anchor"></a><code><span class="keyword">type</span> firstbyte_info</code> = <code>[ </code><table class="variant"><tr id="type-firstbyte_info.Char" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.Char" class="anchor"></a><code>| </code><code>`Char <span class="keyword">of</span> char</code></td><td class="doc"><p>Fixed first character</p></td></tr><tr id="type-firstbyte_info.Start_only" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.Start_only" class="anchor"></a><code>| </code><code>`Start_only</code></td><td class="doc"><p>Pattern matches at beginning and end of newlines</p></td></tr><tr id="type-firstbyte_info.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.ANCHORED" class="anchor"></a><code>| </code><code>`ANCHORED</code></td><td class="doc"><p>Pattern is anchored</p></td></tr></table><code> ]</code></dt><dd><p>Information on matching of &quot;first chars&quot; in patterns</p></dd></dl><dl><dt class="spec type" id="type-study_stat"><a href="#type-study_stat" class="anchor"></a><code><span class="keyword">type</span> study_stat</code> = <code>[ </code><table class="variant"><tr id="type-study_stat.Not_studied" class="anchored"><td class="def constructor"><a href="#type-study_stat.Not_studied" class="anchor"></a><code>| </code><code>`Not_studied</code></td><td class="doc"><p>Pattern has not yet been studied</p></td></tr><tr id="type-study_stat.Studied" class="anchored"><td class="def constructor"><a href="#type-study_stat.Studied" class="anchor"></a><code>| </code><code>`Studied</code></td><td class="doc"><p>Pattern has been studied successfully</p></td></tr><tr id="type-study_stat.Optimal" class="anchored"><td class="def constructor"><a href="#type-study_stat.Optimal" class="anchor"></a><code>| </code><code>`Optimal</code></td><td class="doc"><p>Pattern could not be improved by studying</p></td></tr></table><code> ]</code></dt><dd><p>Information on the study status of patterns</p></dd></dl><dl><dt class="spec type" id="type-regexp"><a href="#type-regexp" class="anchor"></a><code><span class="keyword">type</span> regexp</code></dt><dd><p>Compiled regular expressions</p></dd></dl><dl><dt class="spec value" id="val-options"><a href="#val-options" class="anchor"></a><code><span class="keyword">val</span> options : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> <a href="index.html#type-icflag">icflag</a></code></dt><dd><p><code>options regexp</code> </p><dl><dt>returns</dt><dd><p>compilation flags of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size regexp</code> </p><dl><dt>returns</dt><dd><p>memory size of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-studysize"><a href="#val-studysize" class="anchor"></a><code><span class="keyword">val</span> studysize : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>studysize regexp</code> </p><dl><dt>returns</dt><dd><p>memory size of study information of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-capturecount"><a href="#val-capturecount" class="anchor"></a><code><span class="keyword">val</span> capturecount : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>capturecount regexp</code> </p><dl><dt>returns</dt><dd><p>number of capturing subpatterns in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-backrefmax"><a href="#val-backrefmax" class="anchor"></a><code><span class="keyword">val</span> backrefmax : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>backrefmax regexp</code> </p><dl><dt>returns</dt><dd><p>number of highest backreference in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-namecount"><a href="#val-namecount" class="anchor"></a><code><span class="keyword">val</span> namecount : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>namecount regexp</code> </p><dl><dt>returns</dt><dd><p>number of named subpatterns in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-nameentrysize"><a href="#val-nameentrysize" class="anchor"></a><code><span class="keyword">val</span> nameentrysize : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>nameentrysize regexp</code> </p><dl><dt>returns</dt><dd><p>size of longest name of named subpatterns in <code>regexp</code> + 3.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-names"><a href="#val-names" class="anchor"></a><code><span class="keyword">val</span> names : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string array</code></dt><dd><p><code>names regex</code> </p><dl><dt>returns</dt><dd><p>array of names of named substrings in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-firstbyte"><a href="#val-firstbyte" class="anchor"></a><code><span class="keyword">val</span> firstbyte : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> <a href="index.html#type-firstbyte_info">firstbyte_info</a></code></dt><dd><p><code>firstbyte regexp</code> </p><dl><dt>returns</dt><dd><p>firstbyte info on <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-firsttable"><a href="#val-firsttable" class="anchor"></a><code><span class="keyword">val</span> firsttable : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>firsttable regexp</code> </p><dl><dt>returns</dt><dd><p>some 256-bit (32-byte) fixed set table in form of a string for <code>regexp</code> if available, <code>None</code> otherwise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lastliteral"><a href="#val-lastliteral" class="anchor"></a><code><span class="keyword">val</span> lastliteral : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>lastliteral regexp</code> </p><dl><dt>returns</dt><dd><p>some last matching character of <code>regexp</code> if available, <code>None</code> otherwise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-study_stat"><a href="#val-study_stat" class="anchor"></a><code><span class="keyword">val</span> study_stat : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> <a href="index.html#type-study_stat">study_stat</a></code></dt><dd><p><code>study_stat regexp</code> </p><dl><dt>returns</dt><dd><p>study status of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_stringnumber"><a href="#val-get_stringnumber" class="anchor"></a><code><span class="keyword">val</span> get_stringnumber : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_stringnumber rex name</code> </p><dl><dt>returns</dt><dd><p>the index of the named substring <code>name</code> in regular expression <code>rex</code>. This index can then be used with <code>get_substring</code>.</p></dd></dl><dl><dt>raises Invalid_arg</dt><dd><p>if there is no such named substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_match_limit"><a href="#val-get_match_limit" class="anchor"></a><code><span class="keyword">val</span> get_match_limit : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>get_match_limit rex</code> </p><dl><dt>returns</dt><dd><p>some match limit of regular expression <code>rex</code> or <code>None</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_match_limit_recursion"><a href="#val-get_match_limit_recursion" class="anchor"></a><code><span class="keyword">val</span> get_match_limit_recursion : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>get_match_limit_recursion rex</code> </p><dl><dt>returns</dt><dd><p>some recursion match limit of regular expression <code>rex</code> or <code>None</code>.</p></dd></dl></dd></dl></section><section><header><h6 id="compilation-of-patterns"><a href="#compilation-of-patterns" class="anchor"></a>Compilation of patterns</h6></header><dl><dt class="spec type" id="type-chtables"><a href="#type-chtables" class="anchor"></a><code><span class="keyword">type</span> chtables</code></dt><dd><p>Alternative set of char tables for pattern matching</p></dd></dl><dl><dt class="spec value" id="val-maketables"><a href="#val-maketables" class="anchor"></a><code><span class="keyword">val</span> maketables : unit <span>&#45;&gt;</span> <a href="index.html#type-chtables">chtables</a></code></dt><dd><p>Generates new set of char tables for the current locale.</p></dd></dl><dl><dt class="spec value" id="val-regexp"><a href="#val-regexp" class="anchor"></a><code><span class="keyword">val</span> regexp : ?&#8288;study:bool <span>&#45;&gt;</span> ?&#8288;limit:int <span>&#45;&gt;</span> ?&#8288;limit_recursion:int <span>&#45;&gt;</span> ?&#8288;iflags:<a href="index.html#type-icflag">icflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-cflag">cflag</a> list <span>&#45;&gt;</span> ?&#8288;chtables:<a href="index.html#type-chtables">chtables</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a></code></dt><dd><p><code>regexp ?study ?limit ?limit_recursion ?iflags ?flags ?chtables pattern</code> compiles <code>pattern</code> with <code>flags</code> when given, with <code>iflags</code> otherwise, and with char tables <code>chtables</code>. If <code>study</code> is true, then the resulting regular expression will be studied. If <code>limit</code> is specified, this sets a limit to the amount of recursion and backtracking (only lower than the builtin default!). If this limit is exceeded, <code>MatchLimit</code> will be raised during matching.</p><dl><dt>parameter study</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter limit</dt><dd><p>default = no extra limit other than default</p></dd></dl><dl><dt>parameter limit_recursion</dt><dd><p>default = no extra limit_recursion other than default</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter chtables</dt><dd><p>default = builtin char tables</p></dd></dl><dl><dt>returns</dt><dd><p>the regular expression.</p><p>For detailed documentation on how you can specify PERL-style regular expressions (= patterns), please consult the PCRE-documentation (&quot;man pcrepattern&quot;) or PERL-manuals.</p></dd></dl><dl><dt>see <a href="http://www.perl.com">http://www.perl.com</a></dt><dd><p>www.perl.com</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-regexp_or"><a href="#val-regexp_or" class="anchor"></a><code><span class="keyword">val</span> regexp_or : ?&#8288;study:bool <span>&#45;&gt;</span> ?&#8288;limit:int <span>&#45;&gt;</span> ?&#8288;limit_recursion:int <span>&#45;&gt;</span> ?&#8288;iflags:<a href="index.html#type-icflag">icflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-cflag">cflag</a> list <span>&#45;&gt;</span> ?&#8288;chtables:<a href="index.html#type-chtables">chtables</a> <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a></code></dt><dd><p><code>regexp_or ?study ?limit ?limit_recursion ?iflags ?flags ?chtables patterns</code> like <a href="index.html#type-regexp"><code>regexp</code></a>, but combines <code>patterns</code> as alternatives (or-patterns) into one regular expression.</p></dd></dl><dl><dt class="spec value" id="val-quote"><a href="#val-quote" class="anchor"></a><code><span class="keyword">val</span> quote : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>quote str</code> </p><dl><dt>returns</dt><dd><p>the quoted string of <code>str</code>.</p></dd></dl></dd></dl></section><section><header><h6 id="subpattern-extraction"><a href="#subpattern-extraction" class="anchor"></a>Subpattern extraction</h6></header><dl><dt class="spec type" id="type-substrings"><a href="#type-substrings" class="anchor"></a><code><span class="keyword">type</span> substrings</code></dt><dd><p>Information on substrings after pattern matching</p></dd></dl><dl><dt class="spec value" id="val-get_subject"><a href="#val-get_subject" class="anchor"></a><code><span class="keyword">val</span> get_subject : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_subject substrings</code> </p><dl><dt>returns</dt><dd><p>the subject string of <code>substrings</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-num_of_subs"><a href="#val-num_of_subs" class="anchor"></a><code><span class="keyword">val</span> num_of_subs : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>num_of_subs substrings</code> </p><dl><dt>returns</dt><dd><p>number of strings in <code>substrings</code> (whole match inclusive).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_substring"><a href="#val-get_substring" class="anchor"></a><code><span class="keyword">val</span> get_substring : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_substring substrings n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>th substring (0 is whole match) of <code>substrings</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is not in the range of the number of substrings.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_substring_ofs"><a href="#val-get_substring_ofs" class="anchor"></a><code><span class="keyword">val</span> get_substring_ofs : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int * int</code></dt><dd><p><code>get_substring_ofs substrings n</code> </p><dl><dt>returns</dt><dd><p>the offset tuple of the <code>n</code>th substring of <code>substrings</code> (0 is whole match).</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is not in the range of the number of substrings.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_substrings"><a href="#val-get_substrings" class="anchor"></a><code><span class="keyword">val</span> get_substrings : ?&#8288;full_match:bool <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string array</code></dt><dd><p><code>get_substrings ?full_match substrings</code> </p><dl><dt>returns</dt><dd><p>the array of substrings in <code>substrings</code>. It includes the full match at index 0 when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. If a subpattern did not capture a substring, the empty string is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_opt_substrings"><a href="#val-get_opt_substrings" class="anchor"></a><code><span class="keyword">val</span> get_opt_substrings : ?&#8288;full_match:bool <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string option array</code></dt><dd><p><code>get_opt_substrings ?full_match substrings</code> </p><dl><dt>returns</dt><dd><p>the array of optional substrings in <code>substrings</code>. It includes <code>Some full_match_str</code> at index 0 when <code>full_match</code> is <code>true</code>, <code>Some captured_substrings</code> only when it is <code>false</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_named_substring"><a href="#val-get_named_substring" class="anchor"></a><code><span class="keyword">val</span> get_named_substring : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_named_substring rex name substrings</code> </p><dl><dt>returns</dt><dd><p>the named substring <code>name</code> in regular expression <code>rex</code> and <code>substrings</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if there is no such named substring.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_named_substring_ofs"><a href="#val-get_named_substring_ofs" class="anchor"></a><code><span class="keyword">val</span> get_named_substring_ofs : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int * int</code></dt><dd><p><code>get_named_substring_ofs rex name substrings</code> </p><dl><dt>returns</dt><dd><p>the offset tuple of the named substring <code>name</code> in regular expression <code>rex</code> and <code>substrings</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if there is no such named substring.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl></section><section><header><h6 id="callouts"><a href="#callouts" class="anchor"></a>Callouts</h6></header><dl><dt class="spec type" id="type-callout_data"><a href="#type-callout_data" class="anchor"></a><code><span class="keyword">type</span> callout_data</code><code> = </code><code>{</code><table class="record"><tr id="type-callout_data.callout_number" class="anchored"><td class="def field"><a href="#type-callout_data.callout_number" class="anchor"></a><code>callout_number : int;</code></td><td class="doc"><p>Callout number</p></td></tr><tr id="type-callout_data.substrings" class="anchored"><td class="def field"><a href="#type-callout_data.substrings" class="anchor"></a><code>substrings : <a href="index.html#type-substrings">substrings</a>;</code></td><td class="doc"><p>Substrings matched so far</p></td></tr><tr id="type-callout_data.start_match" class="anchored"><td class="def field"><a href="#type-callout_data.start_match" class="anchor"></a><code>start_match : int;</code></td><td class="doc"><p>Subject start offset of current match attempt</p></td></tr><tr id="type-callout_data.current_position" class="anchored"><td class="def field"><a href="#type-callout_data.current_position" class="anchor"></a><code>current_position : int;</code></td><td class="doc"><p>Subject offset of current match pointer</p></td></tr><tr id="type-callout_data.capture_top" class="anchored"><td class="def field"><a href="#type-callout_data.capture_top" class="anchor"></a><code>capture_top : int;</code></td><td class="doc"><p>Number of the highest captured substring so far</p></td></tr><tr id="type-callout_data.capture_last" class="anchored"><td class="def field"><a href="#type-callout_data.capture_last" class="anchor"></a><code>capture_last : int;</code></td><td class="doc"><p>Number of the most recently captured substring</p></td></tr><tr id="type-callout_data.pattern_position" class="anchored"><td class="def field"><a href="#type-callout_data.pattern_position" class="anchor"></a><code>pattern_position : int;</code></td><td class="doc"><p>Offset of next match item in pattern string</p></td></tr><tr id="type-callout_data.next_item_length" class="anchored"><td class="def field"><a href="#type-callout_data.next_item_length" class="anchor"></a><code>next_item_length : int;</code></td><td class="doc"><p>Length of next match item in pattern string</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-callout"><a href="#type-callout" class="anchor"></a><code><span class="keyword">type</span> callout</code><code> = <a href="index.html#type-callout_data">callout_data</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of callout functions</p><p>Callouts are referred to in patterns as &quot;(?Cn)&quot; where &quot;n&quot; is a <code>callout_number</code> ranging from 0 to 255. Substrings captured so far are accessible as usual via <code>substrings</code>. You will have to consider <code>capture_top</code> and <code>capture_last</code> to know about the current state of valid substrings.</p><p>By raising exception <code>Backtrack</code> within a callout function, the user can force the pattern matching engine to backtrack to other possible solutions. Other exceptions will terminate matching immediately and return control to OCaml.</p></dd></dl></section><section><header><h6 id="matching-of-patterns-and-subpattern-extraction"><a href="#matching-of-patterns-and-subpattern-extraction" class="anchor"></a>Matching of patterns and subpattern extraction</h6></header><dl><dt class="spec value" id="val-pcre_exec"><a href="#val-pcre_exec" class="anchor"></a><code><span class="keyword">val</span> pcre_exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int array</code></dt><dd><p><code>pcre_exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p>an array of offsets that describe the position of matched subpatterns in the string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. The array also contains additional workspace needed by the match engine. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pcre_dfa_exec"><a href="#val-pcre_dfa_exec" class="anchor"></a><code><span class="keyword">val</span> pcre_dfa_exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> ?&#8288;workspace:int array <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int array</code></dt><dd><p><code>pcre_dfa_exec ?iflags ?flags ?rex ?pat ?pos ?callout ?workspace subj</code> invokes the &quot;alternative&quot; DFA matching function.</p><dl><dt>returns</dt><dd><p>an array of offsets that describe the position of matched subpatterns in the string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. The array also contains additional workspace needed by the match engine. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Requires a sufficiently-large <code>workspace</code> array. Callouts are handled by <code>callout</code>.</p><p>Note that the returned array of offsets are quite different from those returned by <a href="index.html#val-pcre_exec"><code>pcre_exec</code></a> et al. The motivating use case for the DFA match function is to be able to restart a partial match with N additional input segments. Because the match function/workspace does not store segments seen previously, the offsets returned when a match completes will refer only to the matching portion of the last subject string provided. Thus, returned offsets from this function should not be used to support extracting captured submatches. If you need to capture submatches from a series of inputs incrementally matched with this function, you'll need to concatenate those inputs that yield a successful match here and re-run the same pattern against that single subject string.</p><p>Aside from an absolute minimum of <code>20</code>, PCRE does not provide any guidance regarding the size of workspace array needed by any given pattern. Therefore, it is wise to appropriately handle the possible <code>WorkspaceSize</code> error. If raised, you can allocate a new, larger workspace array and begin the DFA matching process again.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>parameter workspace</dt><dd><p>default = fresh array of length <code>20</code></p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the pattern match has failed</p></dd></dl><dl><dt>raises Error</dt><dd><p>Partial if the pattern has matched partially; a subsequent exec call with the same pattern and workspace (adding the <code>DFA_RESTART</code> flag) be made to either further advance or complete the partial match.</p></dd></dl><dl><dt>raises Error</dt><dd><p>WorkspaceSize if the workspace array is too small to accommodate the DFA state required by the supplied pattern</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span class="keyword">val</span> exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a></code></dt><dd><p><code>exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p>substring information on string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exec_all"><a href="#val-exec_all" class="anchor"></a><code><span class="keyword">val</span> exec_all : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> array</code></dt><dd><p><code>exec_all ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p>an array of substring information of all matching substrings in string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-next_match"><a href="#val-next_match" class="anchor"></a><code><span class="keyword">val</span> next_match : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a></code></dt><dd><p><code>next_match ?iflags ?flags ?rex ?pat ?pos ?callout substrs</code> </p><dl><dt>returns</dt><dd><p>substring information on the match that follows on the last match denoted by <code>substrs</code>, jumping over <code>pos</code> characters (also backwards!), using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl><dl><dt>raises Invalid_arg</dt><dd><p>if <code>pos</code> let matching start outside of the subject string.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array</code></dt><dd><p><code>extract ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>the array of substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes the full match at index 0 when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, the empty string is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract_opt"><a href="#val-extract_opt" class="anchor"></a><code><span class="keyword">val</span> extract_opt : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option array</code></dt><dd><p><code>extract_opt ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>the array of optional substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes <code>Some full_match_str</code> at index 0 when <code>full_match</code> is <code>true</code>, <code>Some captured-substrings</code> only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract_all"><a href="#val-extract_all" class="anchor"></a><code><span class="keyword">val</span> extract_all : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array array</code></dt><dd><p><code>extract_all ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>an array of arrays of all matching substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes the full match at index 0 of the extracted string arrays when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract_all_opt"><a href="#val-extract_all_opt" class="anchor"></a><code><span class="keyword">val</span> extract_all_opt : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option array array</code></dt><dd><p><code>extract_all_opt
      ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>an array of arrays of all optional matching substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes <code>Some full_match_str</code> at index 0 of the extracted string arrays when <code>full_match</code> is <code>true</code>, <code>Some captured_substrings</code> only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pmatch"><a href="#val-pmatch" class="anchor"></a><code><span class="keyword">val</span> pmatch : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>pmatch ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p><code>true</code> if <code>subj</code> is matched by pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl></section><section><header><h6 id="string-substitution"><a href="#string-substitution" class="anchor"></a>String substitution</h6></header><dl><dt class="spec type" id="type-substitution"><a href="#type-substitution" class="anchor"></a><code><span class="keyword">type</span> substitution</code></dt><dd><p>Information on substitution patterns</p></dd></dl><dl><dt class="spec value" id="val-subst"><a href="#val-subst" class="anchor"></a><code><span class="keyword">val</span> subst : string <span>&#45;&gt;</span> <a href="index.html#type-substitution">substitution</a></code></dt><dd><p><code>subst str</code> converts the string <code>str</code> representing a substitution pattern to the internal representation</p><p>The contents of the substitution string <code>str</code> can be normal text mixed with any of the following (mostly as in PERL):</p><ul><li><em>$[0-9]+</em> - a &quot;$&quot; immediately followed by an arbitrary number. &quot;$0&quot; stands for the name of the executable, any other number for the n-th backreference.</li><li><em>$&amp;</em> - the whole matched pattern</li><li><em>$`</em> - the text before the match</li><li><em>$'</em> - the text after the match</li><li><em>$+</em> - the last group that matched</li><li><em>$$</em> - a single &quot;$&quot;</li><li><em>$!</em> - delimiter which does not appear in the substitution. Can be used to part &quot;$<code>0-9</code>+&quot; from an immediately following other number.</li></ul></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;itempl:<a href="index.html#type-substitution">substitution</a> <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>replace ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the substitution string <code>templ</code> when given, <code>itempl</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter itempl</dt><dd><p>default = empty string</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if there are backreferences to nonexistent subpatterns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-qreplace"><a href="#val-qreplace" class="anchor"></a><code><span class="keyword">val</span> qreplace : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>qreplace ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the string <code>templ</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute_substrings"><a href="#val-substitute_substrings" class="anchor"></a><code><span class="keyword">val</span> substitute_substrings : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(<a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute_substrings ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the substrings of the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute"><a href="#val-substitute" class="anchor"></a><code><span class="keyword">val</span> substitute : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(string <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-replace_first"><a href="#val-replace_first" class="anchor"></a><code><span class="keyword">val</span> replace_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;itempl:<a href="index.html#type-substitution">substitution</a> <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>replace_first ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the substitution string <code>templ</code> when given, <code>itempl</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter itempl</dt><dd><p>default = empty string</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if there are backreferences to nonexistent subpatterns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-qreplace_first"><a href="#val-qreplace_first" class="anchor"></a><code><span class="keyword">val</span> qreplace_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>qreplace_first ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the string <code>templ</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute_substrings_first"><a href="#val-substitute_substrings_first" class="anchor"></a><code><span class="keyword">val</span> substitute_substrings_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(<a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute_substrings_first
       ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the substrings of the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute_first"><a href="#val-substitute_first" class="anchor"></a><code><span class="keyword">val</span> substitute_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(string <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute_first ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl></section><section><header><h6 id="splitting"><a href="#splitting" class="anchor"></a>Splitting</h6></header><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code>subj</code> into a list of at most <code>max</code> strings, using as delimiter pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. If <code>max</code> is zero, trailing empty fields are stripped. If it is negative, it is treated as arbitrarily large. If neither <code>pat</code> nor <code>rex</code> are specified, leading whitespace will be stripped! Should behave exactly as in PERL. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter max</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asplit"><a href="#val-asplit" class="anchor"></a><code><span class="keyword">val</span> asplit : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array</code></dt><dd><p><code>asplit ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> same as <a href="index.html#val-split"><code>Pcre.split</code></a> but </p><dl><dt>returns</dt><dd><p>an array instead of a list.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-split_result"><a href="#type-split_result" class="anchor"></a><code><span class="keyword">type</span> split_result</code><code> = </code><table class="variant"><tr id="type-split_result.Text" class="anchored"><td class="def constructor"><a href="#type-split_result.Text" class="anchor"></a><code>| </code><code><span class="constructor">Text</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Text part of split string</p></td></tr><tr id="type-split_result.Delim" class="anchored"><td class="def constructor"><a href="#type-split_result.Delim" class="anchor"></a><code>| </code><code><span class="constructor">Delim</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Delimiter part of split string</p></td></tr><tr id="type-split_result.Group" class="anchored"><td class="def constructor"><a href="#type-split_result.Group" class="anchor"></a><code>| </code><code><span class="constructor">Group</span> <span class="keyword">of</span> int * string</code></td><td class="doc"><p>Subgroup of matched delimiter (subgroup_nr, subgroup_str)</p></td></tr><tr id="type-split_result.NoGroup" class="anchored"><td class="def constructor"><a href="#type-split_result.NoGroup" class="anchor"></a><code>| </code><code><span class="constructor">NoGroup</span></code></td><td class="doc"><p>Unmatched subgroup</p></td></tr></table></dt><dd><p>Result of a <a href="index.html#val-full_split"><code>Pcre.full_split</code></a></p></dd></dl><dl><dt class="spec value" id="val-full_split"><a href="#val-full_split" class="anchor"></a><code><span class="keyword">val</span> full_split : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-split_result">split_result</a> list</code></dt><dd><p><code>full_split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code>subj</code> into a list of at most <code>max</code> elements of type &quot;split_result&quot;, using as delimiter pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. If <code>max</code> is zero, trailing empty fields are stripped. If it is negative, it is treated as arbitrarily large. Should behave exactly as in PERL. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter max</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl></section><section><header><h6 id="additional-convenience-functions"><a href="#additional-convenience-functions" class="anchor"></a>Additional convenience functions</h6></header><dl><dt class="spec value" id="val-foreach_line"><a href="#val-foreach_line" class="anchor"></a><code><span class="keyword">val</span> foreach_line : ?&#8288;ic:<a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>foreach_line ?ic f</code> applies <code>f</code> to each line in inchannel <code>ic</code> until the end-of-file is reached.</p><dl><dt>parameter ic</dt><dd><p>default = stdin</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-foreach_file"><a href="#val-foreach_file" class="anchor"></a><code><span class="keyword">val</span> foreach_file : string list <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>foreach_file filenames f</code> opens each file in the list <code>filenames</code> for input and applies <code>f</code> to each filename and the corresponding channel. Channels are closed after each operation (even when exceptions occur - they get reraised afterwards!).</p></dd></dl></section><section><header><h6 id="unsafe-stuff---use-with-caution!"><a href="#unsafe-stuff---use-with-caution!" class="anchor"></a><b>UNSAFE STUFF - USE WITH CAUTION!</b></h6></header><dl><dt class="spec value" id="val-unsafe_pcre_exec"><a href="#val-unsafe_pcre_exec" class="anchor"></a><code><span class="keyword">val</span> unsafe_pcre_exec : <a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> subj_start:int <span>&#45;&gt;</span> subj:string <span>&#45;&gt;</span> int array <span>&#45;&gt;</span> <a href="index.html#type-callout">callout</a> option <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsafe_pcre_exec flags rex ~pos ~subj_start ~subj offset_vector callout</code>. You should read the C-source to know what happens. If you do not understand it - <b>don't use this function!</b></p></dd></dl><dl><dt class="spec value" id="val-make_ovector"><a href="#val-make_ovector" class="anchor"></a><code><span class="keyword">val</span> make_ovector : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int * int array</code></dt><dd><p><code>make_ovector regexp</code> calculates the tuple (subgroups2, ovector) which is the number of subgroup offsets and the offset array.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_pcre_dfa_exec"><a href="#val-unsafe_pcre_dfa_exec" class="anchor"></a><code><span class="keyword">val</span> unsafe_pcre_dfa_exec : <a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> subj_start:int <span>&#45;&gt;</span> subj:string <span>&#45;&gt;</span> int array <span>&#45;&gt;</span> <a href="index.html#type-callout">callout</a> option <span>&#45;&gt;</span> workspace:int array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsafe_pcre_dfa_exec flags rex ~pos ~subj_start ~subj offset_vector callout
    ~workpace</code>. You should read the C-source to know what happens. If you do not understand it - <b>don't use this function!</b></p></dd></dl></section></div></body></html>